static void ExecuteReGISCommand(KTerm* term, KTermSession* session) {
    if (!session) session = GET_SESSION(term);
    if (term->regis.command == 0) return;
    if (!term->regis.data_pending && term->regis.command != 'S' && term->regis.command != 'W' && term->regis.command != 'F' && term->regis.command != 'R') return;

    int max_idx = term->regis.param_count;

    // --- P: Position ---
    if (term->regis.command == 'P') {
        for (int i = 0; i <= max_idx; i += 2) {
            int val_x = term->regis.params[i];
            bool rel_x = term->regis.params_relative[i];
            int val_y = (i + 1 <= max_idx) ? term->regis.params[i+1] : term->regis.y;

            if (i+1 > max_idx) val_y = term->regis.y; // Fallback if Y completely missing in pair

            bool rel_y = (i + 1 <= max_idx) ? term->regis.params_relative[i+1] : false;

            int target_x = rel_x ? (term->regis.x + val_x) : val_x;
            int target_y = rel_y ? (term->regis.y + val_y) : val_y;

            // Clamp
            if (target_x < term->regis.screen_min_x) target_x = term->regis.screen_min_x;
            if (target_x > term->regis.screen_max_x) target_x = term->regis.screen_max_x;

            if (target_y < term->regis.screen_min_y) target_y = term->regis.screen_min_y;
            if (target_y > term->regis.screen_max_y) target_y = term->regis.screen_max_y;

            term->regis.x = target_x;
            term->regis.y = target_y;

            term->regis.point_count = 0;
        }
    }
    // --- V: Vector (Line) ---
    else if (term->regis.command == 'V') {
        for (int i = 0; i <= max_idx; i += 2) {
            int val_x = term->regis.params[i];
            bool rel_x = term->regis.params_relative[i];
            int val_y = (i + 1 <= max_idx) ? term->regis.params[i+1] : term->regis.y;
            if (i+1 > max_idx && !rel_x) val_y = term->regis.y;

            bool rel_y = (i + 1 <= max_idx) ? term->regis.params_relative[i+1] : false;

            int target_x = rel_x ? (term->regis.x + val_x) : val_x;
            int target_y = rel_y ? (term->regis.y + val_y) : val_y;


            if (target_x < term->regis.screen_min_x) target_x = term->regis.screen_min_x;
            if (target_x > term->regis.screen_max_x) target_x = term->regis.screen_max_x;
            if (target_y < term->regis.screen_min_y) target_y = term->regis.screen_min_y;
            if (target_y > term->regis.screen_max_y) target_y = term->regis.screen_max_y;

            ReGIS_DrawLine(term, term->regis.x, term->regis.y, target_x, target_y);

            term->regis.x = target_x;
            term->regis.y = target_y;
        }
        term->regis.point_count = 0;
    }
    // --- F: Polygon Fill ---
    else if (term->regis.command == 'F') {
        // Collect points but don't draw immediately
        for (int i = 0; i <= max_idx; i += 2) {
            int val_x = term->regis.params[i];
            bool rel_x = term->regis.params_relative[i];
            int val_y = (i + 1 <= max_idx) ? term->regis.params[i+1] : term->regis.y;
            bool rel_y = (i + 1 <= max_idx) ? term->regis.params_relative[i+1] : false;

            int px = rel_x ? (term->regis.x + val_x) : val_x;

            int py = rel_y ? (term->regis.y + val_y) : val_y;

            if (px < term->regis.screen_min_x) px = term->regis.screen_min_x;
            if (px > term->regis.screen_max_x) px = term->regis.screen_max_x;
            if (py < term->regis.screen_min_y) py = term->regis.screen_min_y;
            if (py > term->regis.screen_max_y) py = term->regis.screen_max_y;

            if (term->regis.point_count < 64) {
                 if (term->regis.point_count == 0) {
                     // First point is usually current cursor if implied?
                     // Standard F command might imply current position as start.
                     // We'll add current pos if buffer empty?
                     // ReGIS usually: F(V(P[x,y]...))
                     // Our F implementation just collects points passed to it.
                     // If point_count is 0, we should probably add current cursor?
                     term->regis.point_buffer[0].x = term->regis.x;
                     term->regis.point_buffer[0].y = term->regis.y;
                     term->regis.point_count++;
                 }
                 term->regis.point_buffer[term->regis.point_count].x = px;
                 term->regis.point_buffer[term->regis.point_count].y = py;
                 term->regis.point_count++;
            }
            term->regis.x = px;
            term->regis.y = py;
        }
    }
    // --- C: Circle / Curve ---
    else if (term->regis.command == 'C') {
        if (term->regis.option_command == 'B') {
            // --- B-Spline ---
            for (int i = 0; i <= max_idx; i += 2) {
                int val_x = term->regis.params[i];
                bool rel_x = term->regis.params_relative[i];
                int val_y = (i + 1 <= max_idx) ? term->regis.params[i+1] : term->regis.y;
                bool rel_y = (i + 1 <= max_idx) ? term->regis.params_relative[i+1] : false;

                int px = rel_x ? (term->regis.x + val_x) : val_x;
                int py = rel_y ? (term->regis.y + val_y) : val_y;

                if (term->regis.point_count < 64) {
                    if (term->regis.point_count == 0) {
                        term->regis.point_buffer[0].x = term->regis.x;
                        term->regis.point_buffer[0].y = term->regis.y;
                        term->regis.point_count++;
                    }
                    term->regis.point_buffer[term->regis.point_count].x = px;
                    term->regis.point_buffer[term->regis.point_count].y = py;
                    term->regis.point_count++;
                }
                term->regis.x = px;
                term->regis.y = py;
            }

            // Safety check to prevent infinite loops if points aren't consumed correctly
            if (term->regis.point_count >= 4) {
                for (int i = 0; i <= term->regis.point_count - 4; i++) {
                    int p0x = term->regis.point_buffer[i].x;   int p0y = term->regis.point_buffer[i].y;
                    int p1x = term->regis.point_buffer[i+1].x; int p1y = term->regis.point_buffer[i+1].y;
                    int p2x = term->regis.point_buffer[i+2].x; int p2y = term->regis.point_buffer[i+2].y;
                    int p3x = term->regis.point_buffer[i+3].x; int p3y = term->regis.point_buffer[i+3].y;

                    int seg_steps = 10;
                    int last_x = -1, last_y = -1;

                    for (int s=0; s<=seg_steps; s++) {
                        float t = (float)s / (float)seg_steps;
                        int tx, ty;
                        ReGIS_EvalBSpline(term, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t, &tx, &ty);
                        if (last_x != -1) {
                            ReGIS_DrawLine(term, last_x, last_y, tx, ty);
                        }
                        last_x = tx;
                        last_y = ty;
                    }
                }
                int keep = 3;
                if (term->regis.point_count > keep) {
                    for(int k=0; k<keep; k++) {
                        term->regis.point_buffer[k] = term->regis.point_buffer[term->regis.point_count - keep + k];
                    }
                    term->regis.point_count = keep;
                }
            }
        }
        else if (term->regis.option_command == 'A') {
            // --- Arc ---
            if (max_idx >= 0) {
                int cx_val = term->regis.params[0];
                bool cx_rel = term->regis.params_relative[0];
                int cy_val = (1 <= max_idx) ? term->regis.params[1] : term->regis.y;
                bool cy_rel = (1 <= max_idx) ? term->regis.params_relative[1] : false;

                int cx = cx_rel ? (term->regis.x + cx_val) : cx_val;
                int cy = cy_rel ? (term->regis.y + cy_val) : cy_val;

                int sx = term->regis.x;
                int sy = term->regis.y;

                float dx = (float)(sx - cx);
                float dy = (float)(sy - cy);
                float radius = sqrtf(dx*dx + dy*dy);
                float start_angle = atan2f(dy, dx);

                float degrees = 0;
                if (max_idx >= 2) {
                    degrees = (float)term->regis.params[2];
                }

                int segments = (int)(fabsf(degrees) / 5.0f);
                if (segments < 4) segments = 4;
                float rad_step = (degrees * 3.14159f / 180.0f) / segments;

                float current_angle = start_angle;
                int last_x = sx;
                int last_y = sy;

                for (int i=0; i<segments; i++) {
                    current_angle += rad_step;
                    int nx = cx + (int)(cosf(current_angle) * radius);
                    int ny = cy + (int)(sinf(current_angle) * radius);
                    ReGIS_DrawLine(term, last_x, last_y, nx, ny);
                    last_x = nx;
                    last_y = ny;
                }

                term->regis.x = last_x;
                term->regis.y = last_y;
            }
        }
        else {
            // --- Standard Circle ---
            for (int i = 0; i <= max_idx; i += 2) {
                 int val1 = term->regis.params[i];
                 bool rel1 = term->regis.params_relative[i];

                 int radius = 0;
                 if (i + 1 > max_idx) {
                     radius = val1;
                 } else {
                     int val2 = term->regis.params[i+1];
                     bool rel2 = term->regis.params_relative[i+1];
                     int px = rel1 ? (term->regis.x + val1) : val1;
                     int py = rel2 ? (term->regis.y + val2) : val2;
                     float dx = (float)(px - term->regis.x);
                     float dy = (float)(py - term->regis.y);
                     radius = (int)sqrtf(dx*dx + dy*dy);
                 }

                 int cx = term->regis.x;
                 int cy = term->regis.y;
                 int segments = 32;
                 float angle_step = 6.283185f / segments;

                 for (int j = 0; j < segments; j++) {
                    if (term->vector_count >= term->vector_capacity) break;
                    float a1 = j * angle_step;
                    float a2 = (j + 1) * angle_step;

                    int x1 = cx + (int)(cosf(a1) * radius);
                    int y1 = cy + (int)(sinf(a1) * radius);
                    int x2 = cx + (int)(cosf(a2) * radius);
                    int y2 = cy + (int)(sinf(a2) * radius);

                    ReGIS_DrawLine(term, x1, y1, x2, y2);
                 }
            }
        }
    }
    // --- S: Screen Control ---
    else if (term->regis.command == 'S') {
        if (term->regis.option_command == 'E') {
             // Screen Erase (and optional addressing per prompt behavior)
             if (term->regis.param_count >= 3) {
                 // S(E[x1,y1][x2,y2]) - Set addressing extent and erase
                 term->regis.screen_min_x = term->regis.params[0];
                 term->regis.screen_min_y = term->regis.params[1];
                 term->regis.screen_max_x = term->regis.params[2];
                 term->regis.screen_max_y = term->regis.params[3];
             }
