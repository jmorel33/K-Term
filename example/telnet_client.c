// KTerm Telnet Client Example
// Requires: Situation Framework (or mock_situation.h for headless testing)
// Compile: gcc example/telnet_client.c -o telnet_client -lkterm -lsituation -lm ...

#define KTERM_IMPLEMENTATION
#include "../kterm.h"

// Mock Fixes for Headless Compilation Check
#ifdef KTERM_TESTING
    #define SIT_KEY_LEFT_CONTROL 0
    #define SIT_KEY_RIGHT_CONTROL 0
    #define SIT_KEY_LEFT_ALT 0
    #define SIT_KEY_RIGHT_ALT 0
    #define SIT_KEY_LEFT_SHIFT 0
    #define SIT_KEY_RIGHT_SHIFT 0
    #define SIT_KEY_PAGE_UP 0
    #define SIT_KEY_PAGE_DOWN 0
    #define GLFW_MOUSE_BUTTON_LEFT 0
    #define GLFW_MOUSE_BUTTON_MIDDLE 1
    #define GLFW_MOUSE_BUTTON_RIGHT 2
    static inline int SituationIsKeyDown(int k) { return 0; }
    static inline int SituationGetKeyPressed() { return 0; }
    static inline int SituationGetCharPressed() { return 0; }
    static inline Vector2 SituationGetMousePosition() { return (Vector2){{0,0}}; }
    static inline int SituationGetMouseWheelMove() { return 0; }
    static inline int SituationIsMouseButtonDown(int b) { return 0; }
    static inline int SituationIsMouseButtonPressed(int b) { return 0; }
    static inline int SituationIsMouseButtonReleased(int b) { return 0; }
    static inline int WindowShouldClose() { return 1; }
    static inline void ClearBackground(Color c) {}
    // Redefine InitInfo to satisfy struct usage
    typedef struct { int window_width; int window_height; const char* window_title; int initial_active_window_flags; } KTermInitInfo_Mock;
    #define KTermInitInfo KTermInitInfo_Mock
    #undef KTerm_Platform_Init
    static inline int KTerm_Platform_Init(int f, void* c, void* i) { return 0; }
#endif

// Integrate Situation Input Adapter
#define KTERM_IO_SIT_IMPLEMENTATION
#include "../kt_io_sit.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// --- Telnet Logic ---

// Options (RFC 854 / 857 / 858)
#define TELNET_OPT_ECHO 1
#define TELNET_OPT_SGA  3

bool on_telnet_command(KTerm* term, KTermSession* session, unsigned char command, unsigned char option) {
    (void)term;
    printf("[Telnet] Command: %d Option: %d\n", command, option);

    // Negotiate ECHO
    if (option == TELNET_OPT_ECHO) {
        if (command == KTERM_TELNET_WILL) {
            // Server wants to echo back. We agree (DO).
            printf("[Telnet] Enabling Remote Echo (Server WILL ECHO)\n");
            KTerm_Net_SendTelnetCommand(term, session, KTERM_TELNET_DO, TELNET_OPT_ECHO);
            // Disable local echo as server will handle it
            session->dec_modes &= ~KTERM_MODE_LOCALECHO;
            return true;
        } else if (command == KTERM_TELNET_DO) {
            // Server wants US to echo? Usually server echoes.
            // We refuse (WONT).
            KTerm_Net_SendTelnetCommand(term, session, KTERM_TELNET_WONT, TELNET_OPT_ECHO);
            return true;
        }
    }

    // Negotiate Suppress Go Ahead (SGA)
    if (option == TELNET_OPT_SGA) {
        if (command == KTERM_TELNET_WILL) {
            KTerm_Net_SendTelnetCommand(term, session, KTERM_TELNET_DO, TELNET_OPT_SGA);
            return true;
        }
    }

    // Default behavior will reject (DONT/WONT) anything else in kt_net.h
    return false;
}

// --- Async Callbacks ---

void on_connect(KTerm* term, KTermSession* session) {
    printf("[Client] Connected to Telnet server!\n");
    KTerm_WriteString(term, "\x1B[32m[Client] Connected to server.\x1B[0m\r\n");
}

void on_disconnect(KTerm* term, KTermSession* session) {
    printf("[Client] Disconnected from server.\n");
    KTerm_WriteString(term, "\r\n\x1B[31m[Client] Disconnected.\x1B[0m\r\n");
    // In a real app, you might trigger a reconnect timer here
}

void on_data(KTerm* term, KTermSession* session, const char* data, size_t len) {
    // Debug raw data if needed
    // printf("[Client] Received %zu bytes\n", len);
}

void on_error(KTerm* term, KTermSession* session, const char* msg) {
    fprintf(stderr, "[Client] Error: %s\n", msg);
    char buf[256];
    snprintf(buf, sizeof(buf), "\r\n\x1B[31m[Client] Error: %s\x1B[0m\r\n", msg);
    KTerm_WriteString(term, buf);
}

void on_response(KTerm* term, const char* response, int length) {
    // This callback receives data generated by the terminal (e.g. keyboard input)
    // We forward it to the network.
    // However, if we use KTerm_Net_Init, it automatically sets the output sink to KTerm_Net_Sink.
    // If connection is active, KTerm_Net_Sink sends to network.
    // If not active, it falls back to this callback if registered via KTermConfig.response_callback.
    // But KTerm_Net_Init overwrites the sink.
    // So this might only be called if we manually set response_callback AND net is disconnected/fallback.
    printf("Local Response: %.*s\n", length, response);
}

int main(int argc, char** argv) {
    const char* host = "towel.blinkenlights.nl"; // Classic Star Wars Telnet
    int port = 23;

    if (argc > 1) host = argv[1];
    if (argc > 2) port = atoi(argv[2]);

    // 1. Initialize Windowing (Situation)
    KTermInitInfo init_info = {
        .window_width = 1024,
        .window_height = 768,
        .window_title = "KTerm Telnet Client",
        .initial_active_window_flags = KTERM_WINDOW_STATE_RESIZABLE
    };

    if (KTerm_Platform_Init(0, NULL, &init_info) != KTERM_SUCCESS) {
        fprintf(stderr, "Failed to initialize platform backend.\n");
        return 1;
    }
    KTerm_SetTargetFPS(60);

    // 2. Initialize KTerm
    KTermConfig config = {0};
    config.width = 80;
    config.height = 24;
    config.response_callback = on_response; // Fallback

    KTerm* term = KTerm_Create(config);
    if (!term) return 1;

    // 3. Setup Networking
    // Initialize Net Module (registers Sink)
    KTerm_Net_Init(term);

    // Setup Session 0
    KTermSession* session = &term->sessions[0];

    // Register Callbacks
    KTermNetCallbacks callbacks = {
        .on_connect = on_connect,
        .on_disconnect = on_disconnect,
        .on_data = on_data,
        .on_error = on_error,
        .on_telnet_command = on_telnet_command
    };
    KTerm_Net_SetCallbacks(term, session, callbacks);

    // Set Protocol to Telnet
    KTerm_Net_SetProtocol(term, session, KTERM_NET_PROTO_TELNET);

    // Enable Keep-Alive (Example of new feature)
    KTerm_Net_SetKeepAlive(term, session, true, 60);

    // Connect
    char msg[256];
    snprintf(msg, sizeof(msg), "Connecting to %s:%d...\r\n", host, port);
    KTerm_WriteString(term, msg);

    KTerm_Net_Connect(term, session, host, port, NULL, NULL);

    // 4. Main Loop
    while (!WindowShouldClose()) {
        // Process Window & Input Events
        KTermSit_ProcessInput(term); // Translates keys to terminal input

        // Update Terminal (Timers, Parsing, Network I/O)
        KTerm_Update(term);

        // Render
        KTerm_BeginFrame();
            ClearBackground((Color){0, 0, 0, 255});
            KTerm_Draw(term);
        KTerm_EndFrame();
    }

    // Cleanup
    KTerm_Net_Disconnect(term, session);
    KTerm_Destroy(term);
    KTerm_Platform_Shutdown();

    return 0;
}
