#define KTERM_IMPLEMENTATION
#define KTERM_TESTING
#define KTERM_ENABLE_GATEWAY
#include "../kterm.h"
#include "test_utilities.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <time.h>

// Mock Response Callback that does nothing (sink) to avoid printing to stdout during benchmark
void benchmark_sink_callback(KTerm* term, const char* response, int length) {
    (void)term; (void)response; (void)length;
}

// Benchmark: Speedtest Graph Rendering Overhead
// This simulates the escape sequences generated by a high-frequency speedtest update
// and measures how fast KTerm can parse and render them.
void benchmark_speedtest_rendering(KTerm* term, KTermSession* session) {
    clock_t start = clock();
    int iterations = 5000;

    // Simulate 5000 frames of updates
    for (int i = 0; i < iterations; i++) {
        // Construct a realistic Speedtest Graph update string (from kt_gateway.h logic)
        // \x1B[3;1H : Move Cursor
        // \x1B[32m : Color Green
        // Download: [======...] 100.00 Mbps
        // \x1B[0m : Reset
        // \x1B[K : Clear Line

        // Vary progress to simulate animation
        float progress = (float)(i % 100) / 100.0f;
        int width = 40;
        int filled = (int)(width * progress);
        char bar[41];
        memset(bar, '=', filled);
        memset(bar + filled, ' ', width - filled);
        bar[40] = '\0';

        char buffer[256];
        snprintf(buffer, sizeof(buffer), "\x1B[3;1H\x1B[32mDownload: [%s] 100.00 Mbps\x1B[0m\x1B[K", bar);

        // Inject into pipeline
        KTerm_WriteString(term, buffer);

        // Process
        KTerm_ProcessEvents(term);

        // Optional: Simulate Draw (Update Op Queue Flush)
        // KTerm_FlushOps is called by KTerm_Update usually.
        // We can call internal flush if exposed, or just rely on ProcessEvents queueing ops.
        // Ops are queued but not necessarily "rendered" to pixels without Draw.
        // But queuing ops is the CPU heavy part of logic.
        KTerm_FlushOps(term, session);
    }

    clock_t end = clock();
    double elapsed = (double)(end - start) / CLOCKS_PER_SEC;

    printf("  Speedtest Graph Rendering: %d updates in %.3f seconds (%.0f updates/sec)\n",
           iterations, elapsed, iterations / elapsed);
}

// Benchmark: Continuous Traceroute Parsing Overhead
// Simulates a stream of traceroute hop updates (Gateway Protocol)
void benchmark_traceroute_parsing(KTerm* term, KTermSession* session) {
    clock_t start = clock();
    int iterations = 10000;

    for (int i = 0; i < iterations; i++) {
        // Construct Gateway Response: ESC P GATE ; KTERM ; ID ; TRACEROUTE ; HOP;... ST
        // Payload: HOP;%d;%s;%.3f%s
        char msg[256];
        snprintf(msg, sizeof(msg), "\033PGATE;KTERM;0;TRACEROUTE;HOP;%d;192.168.1.%d;12.345\033\\", (i % 30) + 1, i % 255);

        // Inject (this goes to Gateway Parser)
        KTerm_WriteString(term, msg);
        KTerm_ProcessEvents(term);
        KTerm_FlushOps(term, session);
    }

    clock_t end = clock();
    double elapsed = (double)(end - start) / CLOCKS_PER_SEC;

    printf("  Traceroute Gateway Parsing: %d packets in %.3f seconds (%.0f packets/sec)\n",
           iterations, elapsed, iterations / elapsed);
}

int main() {
    KTermConfig config = {0};
    config.width = 80;
    config.height = 25;
    config.response_callback = benchmark_sink_callback;

    KTerm* term = KTerm_Create(config);
    if (!term) {
        fprintf(stderr, "Failed to create terminal\n");
        return 1;
    }
    KTerm_Init(term);
    KTermSession* session = &term->sessions[0];

    printf("Running Diagnostics Benchmarks...\n");
    benchmark_speedtest_rendering(term, session);
    benchmark_traceroute_parsing(term, session);

    KTerm_Destroy(term);
    return 0;
}
