#define KTERM_IMPLEMENTATION
#define KTERM_TESTING
#include "../kterm.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>

#ifdef _WIN32
#include <winsock2.h>
#include <ws2tcpip.h>
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#endif

bool auth_called = false;
bool auth_success = false;

bool on_auth(KTerm* term, KTermSession* session, const char* user, const char* pass) {
    (void)term; (void)session;
    auth_called = true;
    printf("Server received Auth: User='%s', Pass='%s'\n", user, pass);
    if (strcmp(user, "testuser") == 0 && strcmp(pass, "testpass") == 0) {
        auth_success = true;
        return true;
    }
    return false;
}

int main() {
    #ifndef _WIN32
    signal(SIGPIPE, SIG_IGN);
    #endif

    KTermConfig config = {80, 24};
    KTerm* term = KTerm_Create(config);
    if (!term) return 1;
    KTerm_Net_Init(term);
    
    KTermSession* session = &term->sessions[0];
    KTermNetCallbacks cbs = {0};
    cbs.on_auth = on_auth;
    KTerm_Net_SetCallbacks(term, session, cbs);
    
    // Start Server
    int port = 9999;
    printf("Starting server on port %d...\n", port);
    KTerm_Net_Listen(term, session, port);
    
    // Process once to ensure listening
    KTerm_Net_Process(term);
    
    // Create a client socket
    #ifdef _WIN32
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &wsaData);
    #endif
    
    int client_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (client_fd < 0) {
        perror("socket");
        return 1;
    }
    
    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    addr.sin_port = htons(port);
    
    printf("Client connecting to 127.0.0.1:%d...\n", port);
    if (connect(client_fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("connect");
        return 1;
    }
    
    // Process server to accept connection
    printf("Processing server loop...\n");
    for(int i=0; i<50; i++) {
        KTerm_Net_Process(term);
        usleep(1000);
    }
    
    // Send user
    printf("Client sending username...\n");
    ssize_t n = send(client_fd, "testuser\n", 9, 0);
    if (n < 0) perror("send user");

    for(int i=0; i<50; i++) {
        KTerm_Net_Process(term);
        usleep(1000);
    }
    
    // Send pass
    printf("Client sending password...\n");
    n = send(client_fd, "testpass\n", 9, 0);
    if (n < 0) perror("send pass");

    for(int i=0; i<50; i++) {
        KTerm_Net_Process(term);
        usleep(1000);
    }
    
    printf("\nFinal Results:\n");
    printf("  Auth called: %d\n", auth_called);
    printf("  Auth success: %d\n", auth_success);
    
    char status_buf[256];
    KTerm_Net_GetStatus(term, session, status_buf, sizeof(status_buf));
    printf("  Server Status: %s\n", status_buf);
    
    if (auth_success) {
        printf("\nRESULT: VULNERABILITY STILL PRESENT! Auth succeeded over cleartext.\n");
    } else {
        if (strstr(status_buf, "STATE=ERROR")) {
            printf("\nRESULT: SUCCESS! Auth was rejected and server is in ERROR state.\n");
            if (strstr(status_buf, "Authentication requires security layer")) {
                 printf("Verified error message: %s\n", status_buf);
            }
        } else {
            printf("\nRESULT: Auth failed but server is in state: %s\n", status_buf);
        }
    }
    
    KTerm_Net_Disconnect(term, session);
    #ifdef _WIN32
    closesocket(client_fd);
    WSACleanup();
    #else
    close(client_fd);
    #endif
    KTerm_Destroy(term);
    
    return 0;
}
